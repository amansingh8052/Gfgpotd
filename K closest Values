# JAVA CODE 

class Solution {
    public ArrayList<Integer> getKClosest(Node root, int target, int k) {
        PriorityQueue<int[]> pq = new PriorityQueue<>(
            (a, b) -> (a[1] == b[1]) ? b[0] - a[0] : b[1] - a[1]
        ); 
        inorder(root, target, k, pq);
        
        ArrayList<Integer> res = new ArrayList<>();
        for (int[] pair : pq)
            res.add(pair[0]);
        
        return res;
    }

    private void inorder(Node root, int target, int k, PriorityQueue<int[]> pq) {
        if (root == null) return;
        
        inorder(root.left, target, k, pq);
        
        int diff = Math.abs(root.data - target);
        pq.offer(new int[]{root.data, diff});
        
        if (pq.size() > k)
            pq.poll();
        
        inorder(root.right, target, k, pq);
    }
}


# C++ CODE 


class Solution {
  public:
    vector<int> getKClosest(Node* root, int target, int k) {
        priority_queue<pair<int, int>> pq;
        inorder(root, target, k, pq);

        vector<int> res;
        while (!pq.empty()) {
            res.push_back(pq.top().second);
            pq.pop();
        }
        return res;
    }

  private:
    void inorder(Node* root, int target, int k, priority_queue<pair<int, int>>& pq) {
        if (!root) return;

        inorder(root->left, target, k, pq);

        int diff = abs(root->data - target);
        pq.push({diff, root->data});

        if ((int)pq.size() > k) {
            auto top1 = pq.top();
            pq.pop();
        }

        inorder(root->right, target, k, pq);
    }
};
